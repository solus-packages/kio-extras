From a36b797913a844dbb26d5dc1542b3ce304f5f445 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michal=20Mal=C3=BD?= <malymi@natur.cuni.cz>
Date: Tue, 31 Oct 2017 18:19:21 -0600
Subject: [PATCH] Workaround incorrectly returned EEXIST instead of EPERM
 regression introduced by libsmbclient 4.7

Summary:
There appears to be an issue with libsmbclient 4.7 that returns nonsensical EEXIST error code when a user has not authenticated themselves to access password-protected shares. This patch attempts to work around the issue by treating EEXIST as another case of "invalid login credentials". The workaround tries to detect broken versions of libsmbclient and enables itself only when such a version is found.

See https://bugzilla.samba.org/show_bug.cgi?id=13050 for upstream bug report.

BUG: 385708

Reviewers: ngraham, davidedmundson, elvisangelaccio, #frameworks

Reviewed By: ngraham, davidedmundson

Subscribers: cfeck, rdieter, graesslin, z3ntu

Differential Revision: https://phabricator.kde.org/D8387
---
 smb/kio_smb.cpp        | 30 +++++++++++++++++++++++++++++-
 smb/kio_smb.h          |  3 +++
 smb/kio_smb_browse.cpp |  7 ++++++-
 3 files changed, 38 insertions(+), 2 deletions(-)

diff --git a/smb/kio_smb.cpp b/smb/kio_smb.cpp
index 2a2e424b..1ea3f99c 100644
--- a/smb/kio_smb.cpp
+++ b/smb/kio_smb.cpp
@@ -31,12 +31,40 @@
 #include "kio_smb.h"
 #include "kio_smb_internal.h"
 #include <QCoreApplication>
+#include <QVersionNumber>
 
 Q_LOGGING_CATEGORY(KIO_SMB, "kio_smb")
 
+bool needsEEXISTWorkaround()
+{
+    /* There is an issue with some libsmbclient versions that return EEXIST
+     * return code from smbc_opendir() instead of EPERM when the user
+     * tries to access a resource that requires login authetification.
+     * We are working around the issue by treating EEXIST as a special case
+     * of "invalid/unavailable credentials" if we detect that we are using
+     * the affected versions of libsmbclient
+     *
+     * Upstream bug report: https://bugzilla.samba.org/show_bug.cgi?id=13050
+     */
+    static const QVersionNumber firstBrokenVer{4, 7, 0};
+    static const QVersionNumber lastBrokenVer{9, 9, 9}; /* Adjust accordingly when this gets fixed upstream */
+
+    const QVersionNumber currentVer = QVersionNumber::fromString(smbc_version());
+    qCDebug(KIO_SMB) << "Using libsmbclient library version" << currentVer;
+
+    if (currentVer >= firstBrokenVer && currentVer <= lastBrokenVer) {
+        qCDebug(KIO_SMB) << "Detected broken libsmbclient version" << currentVer;
+        return true;
+    }
+
+    return false;
+}
+
 //===========================================================================
 SMBSlave::SMBSlave(const QByteArray& pool, const QByteArray& app)
-    : SlaveBase( "smb", pool, app ), m_openFd(-1)
+    : SlaveBase( "smb", pool, app ),
+      m_openFd(-1),
+      m_enableEEXISTWorkaround(needsEEXISTWorkaround())
 {
     m_initialized_smbc = false;
 
diff --git a/smb/kio_smb.h b/smb/kio_smb.h
index 77866b10..22fa036c 100644
--- a/smb/kio_smb.h
+++ b/smb/kio_smb.h
@@ -278,6 +278,7 @@ class SMBSlave : public QObject, public KIO::SlaveBase
     void smbCopy(const QUrl& src, const QUrl &dest, int permissions, KIO::JobFlags flags);
     void smbCopyGet(const QUrl& src, const QUrl& dest, int permissions, KIO::JobFlags flags);
     void smbCopyPut(const QUrl& src, const QUrl& dest, int permissions, KIO::JobFlags flags);
+    bool workaroundEEXIST(const int errNum) const;
 
     void fileSystemFreeSpace(const QUrl &url);
 
@@ -288,6 +289,8 @@ class SMBSlave : public QObject, public KIO::SlaveBase
      */
     int m_openFd;
     SMBUrl m_openUrl;
+
+    const bool m_enableEEXISTWorkaround; /* Enables a workaround for some broken libsmbclient versions */
 };
 
 //==========================================================================
diff --git a/smb/kio_smb_browse.cpp b/smb/kio_smb_browse.cpp
index 5995eec6..47b2b328 100644
--- a/smb/kio_smb_browse.cpp
+++ b/smb/kio_smb_browse.cpp
@@ -473,7 +473,7 @@ void SMBSlave::listDir( const QUrl& kurl )
    }
    else
    {
-       if (errNum == EPERM || errNum == EACCES) {
+       if (errNum == EPERM || errNum == EACCES || workaroundEEXIST(errNum)) {
            if (checkPassword(m_current_url)) {
                redirection( m_current_url );
                finished();
@@ -522,3 +522,8 @@ void SMBSlave::fileSystemFreeSpace(const QUrl& url)
     finished();
 }
 
+bool SMBSlave::workaroundEEXIST(const int errNum) const
+{
+    return (errNum == EEXIST) && m_enableEEXISTWorkaround;
+}
+
